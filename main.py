#Import the necessary libraries
import sys, os
import pandas as pd
from PyQt6.QtWidgets import *
from PyQt6 import uic
from PyQt6.QtCore import QTimer
from PyQt6.QtGui import QIcon

class Interface(QMainWindow):
    def __init__(self):
        super().__init__()

        # Interface connection 
        uic.loadUi(self.resolve_route('interface.ui'), self)

        #Icon
        icon_path = self.resolve_route('icon.ico')
        app_icon = QIcon(icon_path)
        self.setWindowIcon(app_icon)

        # Setting title
        self.setWindowTitle("Vulnerability Status Checker")

        # Table UI
        self.table = self.findChild(QTableWidget, 'tableWidget')
        self.table.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.table.resizeColumnsToContents()

        #Lcds UI
        self.lcd_solved = self.findChild(QLCDNumber, 'lcdNumber_2')
        self.lcd_total = self.findChild(QLCDNumber, 'lcdNumber_3')
        self.lcd_vulnerabilities = self.findChild(QLCDNumber, 'lcdNumber')

        #Search Engine UI
        self.search_engine = self.findChild(QLineEdit, 'lineEdit')
        self.search_engine.textChanged.connect(self.query_table)

        #Buttons UI
        self.btn_file1 = self.findChild(QPushButton, 'pushButton') 
        self.btn_file2 = self.findChild(QPushButton, 'pushButton_2') 
        self.btn_run = self.findChild(QPushButton, 'pushButton_3') 
        self.btn_show_daily = self.findChild(QPushButton, 'pushButton_4')
        self.btn_show_database = self.findChild(QPushButton, 'pushButton_5')
        self.btn_show_new_cves = self.findChild(QPushButton, 'pushButton_6')
        self.btn_export_new_cves = self.findChild(QPushButton, 'pushButton_7')
        self.bnt_save_changes = self.findChild(QPushButton, 'pushButton_8')

        #LineEdit
        self.line_ed_search = self.findChild(QLineEdit, 'lineEdit') 
        self.line_ed_status = self.findChild(QLineEdit, 'lineEdit_2') 

        #CheckBox
        self.cbox_filter = self.findChild(QCheckBox, 'checkBox')
        
        #Connections UI 
        self.btn_file1.clicked.connect(lambda: self.import_file('Open File 1 - Daily')) 
        self.btn_file2.clicked.connect(lambda: self.import_file('Open File 2 - Database'))
        self.btn_run.clicked.connect(lambda: self.run_check())
        self.btn_show_daily.clicked.connect(lambda: self.show_table(self.btn_show_daily.text()))
        self.btn_show_database.clicked.connect(lambda: self.show_table(self.btn_show_database.text()))
        self.btn_show_new_cves.clicked.connect(lambda: self.show_table(self.btn_show_new_cves.text()))
        self.btn_export_new_cves.clicked.connect(lambda: self.export_new_cves())
        self.bnt_save_changes.clicked.connect(lambda: self.save_database_changes())
        self.cbox_filter.stateChanged.connect(self.toggle_columns)

        # Variables
        self.file_type = ''
        self.status = ['File exported successfully', 'File uploaded successfully']
        self.columns_to_filter = [0, 6, 10, 11]

    # Resolve route
    def resolve_route(self, ruta_relativa):
            if hasattr(sys, '_MEIPASS'):
                return os.path.join(sys._MEIPASS, ruta_relativa)
            return os.path.join(os.path.abspath('.'), ruta_relativa)
    
    # Ajuste de widgets
    def resizeEvent(self, event):
        table_width = self.width() - 20
        table_height = self.height() -188
        self.table.setGeometry(10, 178, table_width, table_height)

    def show_table(self, option):
        self.table.resizeColumnsToContents()
        self.line_ed_search.setText("")

        #Show daily file
        if option == 'Show Daily':
            self.line_ed_status.setText("")
            # Reading file 
            try:
                df_daily = self.df_daily
                self.rows = df_daily.shape[0]
                self.columns = df_daily.shape[1]
                
                # UI table settings 
                self.table.setRowCount(self.rows)
                self.table.setColumnCount(self.columns)
                self.name_columns = list(df_daily.columns)
                self.table.setHorizontalHeaderLabels(self.name_columns)
                self.fill_table(df_daily, self.rows, self.columns)
                self.line_ed_status.setText(f"Displaying daily archive information")
            except Exception as e:
                self.table.setRowCount(0)
                self.table.setColumnCount(0)
                self.line_ed_status.setText(f'Error: {type(e).__name__}. Description: {str(e)}')

        #Show database file
        elif option == 'Show Database':
            self.line_ed_status.setText("")
            # Reading file 
            try:
                df_database = self.df_database
                self.rows = df_database.shape[0]
                self.columns = df_database.shape[1]
                
                # UI table settings 
                self.table.setRowCount(self.rows)
                self.table.setColumnCount(self.columns)
                self.name_columns = list(df_database.columns)
                self.table.setHorizontalHeaderLabels(self.name_columns)
                self.fill_table(df_database, self.rows, self.columns)
                self.line_ed_status.setText(f"Displaying database archive information")

            except Exception as e:
                self.table.setRowCount(0)
                self.table.setColumnCount(0)
                self.line_ed_status.setText(f'Error: {type(e).__name__}. Description: {str(e)}')

        #Show new cves file
        elif option == 'Show New CVEs':
            self.line_ed_status.setText("")
            # Reading file 
            try:
                df_new_cves = pd.read_csv(self.file_name, sep=';', encoding='latin-1')
                self.rows = df_new_cves.shape[0]
                self.columns = df_new_cves.shape[1]
                
                # UI table settings 
                self.table.setRowCount(self.rows)
                self.table.setColumnCount(self.columns)
                self.name_columns = list(df_new_cves.columns)
                self.table.setHorizontalHeaderLabels(self.name_columns)
                self.fill_table(df_new_cves, self.rows, self.columns)
                self.line_ed_status.setText(f"Displaying new_cves archive information")

            except Exception as e:
                self.table.setRowCount(0)
                self.table.setColumnCount(0)                
                self.line_ed_status.setText(f'Error: {type(e).__name__}. Description: {str(e)}')

        # Show check run
        elif option == 'Run Check':
            # Reading file 
            try:
                df_database = self.df_database
                self.rows = df_database.shape[0]
                self.columns = df_database.shape[1]
                
                # UI table settings 
                self.table.setRowCount(self.rows)
                self.table.setColumnCount(self.columns)
                self.name_columns = list(df_database.columns)
                self.table.setHorizontalHeaderLabels(self.name_columns)
                self.fill_table(df_database, self.rows, self.columns)

            except Exception as e:
                self.table.setRowCount(0)
                self.table.setColumnCount(0)                
                self.line_ed_status.setText(f'Error: {type(e).__name__}. Description: {str(e)}')
    
    # Llenado de la tabla según sea el caso 
    def fill_table(self, df, rows, columns):
         for row in range(rows):
                    for column in range(columns):
                        data = str(df.iloc[row,column])
                        self.table.setItem(row, column, QTableWidgetItem(data))


    # Cargado del archivo Daily y el archivo Database
    def import_file(self, file_type):
        self.line_ed_search.setText("")
        file_path, _ = QFileDialog.getOpenFileName(self, f"{file_type}", "", "CSV Files (*.csv)")
        if file_path:
            try:
                if file_type == "Open File 1 - Daily":
                    self.df_daily = pd.read_csv(file_path, sep=';', encoding='latin-1')
                    self.line_ed_status.setText(f"Daily file successfully uploaded")
                elif file_type == "Open File 2 - Database":
                    self.df_database = pd.read_csv(file_path, sep=';', encoding='latin-1')
                    self.line_ed_status.setText(f"Database file successfully uploaded")
            except Exception as e:
                self.line_ed_status.setText(f'Error: {type(e).__name__}. Descripción: {str(e)}')
    
    # Ejecución del chequeo del estado de las vulnerabildades
    def run_check(self):
        try:
            self.temp_df = self.df_daily.apply(lambda x: x.str.lower().str.strip()).merge(
                self.df_database[['activo', 'cve_id']].apply(lambda x: x.str.lower().str.strip()),
                on=['activo', 'cve_id'],
                how='outer',
                indicator='indicador'
            )
            
            # Clasificación de las
            self.only_daily = self.temp_df[self.temp_df['indicador']=='left_only'][['activo', 'cve_id']]
            self.only_database = self.temp_df[self.temp_df['indicador']=='right_only'][['activo', 'cve_id']]
            self.only_same = self.temp_df[self.temp_df['indicador']=='both'][['activo', 'cve_id']]

            # Crear una nueva columna que combine activo y cve_id
            self.temp_database = self.df_database.copy()
            self.temp_database = self.temp_database[['activo', 'cve_id']].apply(lambda x: x.str.lower().str.strip())
            self.temp_database['key'] = self.temp_database['activo'] + '_' + self.temp_database['cve_id']
            self.only_daily['key'] = self.only_daily['activo'] + '_' + self.only_daily['cve_id']
            self.only_database['key'] = self.only_database['activo'] + '_' + self.only_database['cve_id']
            self.only_same['key'] = self.only_same['activo'] + '_' + self.only_same['cve_id']

            # Actualización del estado Solucionado 
            format = "%d/%m/%Y" #pd.Timestamp("today").strftime()
            today = pd.to_datetime('today').date().strftime(format)
            self.df_database.loc[(self.temp_database['key'].isin(self.only_database['key'])), 'actualizacion_interlan'] = 'Solucionada'
            self.df_database.loc[(self.temp_database['key'].isin(self.only_database['key'])), 'Fecha actualizacion'] = today

            # Actualización del estado Vulnerable
            self.df_database.loc[(self.temp_database['key'].isin(self.only_same['key'])), 'actualizacion_interlan'] = 'Vulnerable'
            self.df_database.loc[(self.temp_database['key'].isin(self.only_same['key'])), 'Fecha actualizacion'] = today
            self.line_ed_status.setText("Verification has been successfully completed")

            self.set_labels(self.df_database)
            
            return self.show_table(self.btn_run.text())
    
        except Exception as e:
            self.line_ed_status.setText(f'Error: {type(e).__name__}. Descripción: {str(e)}')
    
    # Exportación del archivo que contiene los activos y sus respectivos cves que no estan relacionados en la base de datos principal
    def export_new_cves(self):
        try:
            self.line_ed_search.setText("")
            self.file_name, _ = QFileDialog.getSaveFileName(self,"Save new CVEs as","","Archivos CSV (*.csv)")
            if self.file_name:
                #Se genera el archivo csv con los nuevos CVEs identificados.
                self.only_daily[['activo', 'cve_id']].to_csv(self.file_name, sep=';', encoding='latin-1', index= False)
                self.line_ed_status.setText(f'File exported successfully: {self.file_name}')

        except Exception as e:
            self.line_ed_status.setText(f'Error: {type(e).__name__}. Descripción: {str(e)}')

    # Guardado de la base de datos modificada
    def save_database_changes(self):
        try:
            self.line_ed_search.setText("")
            self.file_changes, _ = QFileDialog.getSaveFileName(self,"Save changes as","","Archivos CSV (*.csv)")
            if self.file_changes:
                #Se genera el archivo con las modificaciones de la verificación en la base de datos original
                self.df_database.to_csv(self.file_changes, sep = ';', encoding='utf-8', index= False)
                self.line_ed_status.setText(f'File saved successfully: {self.file_changes}')
        
        except Exception as e:
            self.line_ed_status.setText(f'Error: {type(e).__name__}. Descripción: {str(e)}')       

    # Motor de consultas en la tabla
    def query_table(self, query):
        # Obtener el modelo de datos de la tabla
        model = self.table.model()
        # Iterar sobre las filas del modelo
        for row in range(model.rowCount()):
            # Concatenar el contenido de la fila en una cadena
            row_data = []
            for column in range(model.columnCount()):
                index = model.index(row, column)
                data = str(model.data(index))
                row_data.append(data)
            row_content = ''.join(row_data)
            # Ocultar o mostrar la fila según la consulta de búsqueda
            match = query.lower() in row_content.lower()
            self.table.setRowHidden(row, not match)
        # Actualizar la vista de la tabla
        self.table.update()

    def toggle_columns(self, checked):
        for i in range(self.table.columnCount()):
            self.table.setColumnHidden(i, i not in self.columns_to_filter and checked)

    #  Visualización de las variables en los lcds
    def set_labels(self, database):
        num_vulnerabilities = self.get_number_vulnerabilities(database)
        num_solved = self.get_number_solved(database)
        self.lcd_vulnerabilities.display(num_vulnerabilities)
        self.lcd_solved.display(num_solved)
        self.lcd_total.display(num_solved + num_vulnerabilities)

    # Cálculo de las vulnerabilidades a mostrar en lcd
    def get_number_vulnerabilities(self, database):
        num_vulnerabilities = database[database['actualizacion_interlan']=='Vulnerable'].shape[0] 
        return num_vulnerabilities

    # Cálculo de los casos solucionados a mostrar en lcd
    def get_number_solved(self, database):
        num_solved = database[database['actualizacion_interlan']=='Solucionada'].shape[0]
        return num_solved

if __name__ == '__main__':
    app = QApplication(sys.argv)
    frame = Interface()
    frame.show()
    sys.exit(app.exec())
